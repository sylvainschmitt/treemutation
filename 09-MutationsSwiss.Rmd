```{r setupmutationsswiss, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
```

```{r datamutationsswiss}
snv <- read_tsv("data/mutations/swiss/napoleon_mutations.tsv")
genome <- read_tsv("data/mutations/swiss/Qrob_PM1N.fa.fai", 
         col_names = c("CHROM", "length", "bytesindex", "basesperline", "bytesperline")) %>% 
  dplyr::select(CHROM, length) %>% 
  mutate(start = 0, stop = length/10^6)
```

```{r, cache=FALSE}
strelka2raw <- src_sqlite("data/mutations/swiss/strelka2_raw.sql") %>% tbl("mutations")
```

# Mutations swiss

This chapter describes the reanalyses of data from @Schmid-Siegert2017 currently done in the [`swiss` branch of the `detectMutations` repository](https://github.com/sylvainschmitt/detectMutations/tree/swiss).

## Napoleon and 3P

I reported the mutations (Tab. \@ref(tab:napoTab)) from the [supplementary table 2](https://static-content.springer.com/esm/art%3A10.1038%2Fs41477-017-0066-9/MediaObjects/41477_2017_66_MOESM1_ESM.pdf) from @Schmid-Siegert2017, and aligned them back on the 3P genome (Fig. \@ref(fig:napoFig)). 
I found back only 14 of the original 17 mutations from Napoleon
Moreover, 3 were not in the assembled chromosome.
Consequently, I will focus on the 11 mutations in the 12 chromosome of the 3P assembly.

```{r napoTab}
kable(snv, caption = "SNVs in the Napoleon Oak. Rerported from @Schmid-Siegert2017.")
```

```{r napoFig, fig.cap="Napoleon's original mutations on the 3P genome."}
ggplot(genome, aes(x = CHROM, xend = CHROM)) +
  geom_segment(aes(y = start, yend = stop), size = 3, col = "grey") +
  geom_point(aes(y = POS/10^6), col = "red", data = snv) +
  ggrepel::geom_label_repel(aes(y = POS/10^6, label = Mutation), col = "red", data = snv) +
  coord_flip() +
  ylab("Position (Mb)") +
  theme(axis.line.y = element_blank(), axis.title.y = element_blank(), 
        axis.ticks.y = element_blank())
```

## Napoelon's original mutations

`Strelka2` produced `r round(collect(tally(strelka2raw))$n/10^6, 1)` millions of candidate mutations.
I tried to find back Napoleon's original mutations to have a look to their metrics.
I found back only 7 out of the 11 expected mutations (63%) (Tab. \@ref(tab:napoMutTab) and Fig. \@ref(fig:napoMutFig)).
**Beware, `Strelka2` is detecting putative mutations in the normal sample !**
I looked at different metrics for each  (Fig. \@ref(fig:overlapMetrics)):

* `mutation_DP` and `normal_DP` are the read depth for the two sample, and shows as expected values between half and two times the mean coverage (60X)
* `normal_altCountT1` is the number of alternate allele count in the normal sample, should be 0, but is equal to 3 and 4 (9% of reads) for two SNVs
* `mutation_altCountT1` is the number of alternate allele count in the mutated sample, should be not too low, and is most the time above 5

**The main conclusion is that the mutations detected by @Schmid-Siegert2017 have not always no reads in the "normal" sample and that they show a wide variation of allelic frequency.**

```{r napoMut}
overlap <- lapply(1:nrow(snv), function(i)
  strelka2raw %>% 
    filter(CHROM == local(snv[i,]$CHROM)) %>% 
    filter(POS == local(snv[i,]$POS)) %>% 
    collect() %>% 
    mutate(Mutation  = snv[i,]$Mutation)
) %>% bind_rows()
```

```{r napoMutTab}
overlap %>% 
  dplyr::select(Mutation, tumor, normal, REF, ALT, mutation_altCountT1, mutation_refCountT1, normal_altCountT1, normal_refCountT1) %>% 
  kable(caption = "Overlap between candidate mutations and Napoleon's original mutations.", 
        col.names = c("Mutation", "Mutated", "Normal", "Ref", "Alt", 
                      "Mutated\nAltCount", "Mutated\nRefCount", "Normal\nAltCount", "Normal\nRefCount"))
```

```{r napoMutFig, fig.cap="Overlap between candidate mutations and Napoleon's original mutations: allele frequency (A) and positions on the 3P genome (B)."}
g1 <- ggplot(overlap, aes(mutation_AF)) +
  geom_histogram() +
  ggtitle("", paste("N =", nrow(overlap))) +
  xlab("Allele frequency")
g2 <- ggplot(genome, aes(x = CHROM, xend = CHROM)) +
  geom_segment(aes(y = start, yend = stop), size = 3, col = "lightgrey") +
  geom_point(aes(y = POS/10^6, col = mutation_AF), data = overlap, size = 1) +
  ggrepel::geom_label_repel(aes(y = POS/10^6, label = Mutation), col = "red", 
                            data = dplyr::select(overlap, CHROM, POS, Mutation) %>% unique()) +
  coord_flip() +
  ylab("Position (Mb)") +
  theme(axis.line.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank()) +
  viridis::scale_color_viridis(option = "inferno")
cowplot::plot_grid(g1, g2, nrow = 2, labels = c("A", "B"))
```

```{r overlapMetrics, fig.cap="Evaluation of the overlap between candidate mutations and Napoleon's original mutations."}
overlap %>% 
  group_by(Mutation) %>% 
  filter(normal_altCountT1 == min(normal_altCountT1)) %>% 
  dplyr::select(Mutation, FILTER, mutation_DP, normal_DP,
                mutation_altCountT1, normal_altCountT1) %>% 
  reshape2::melt(c("Mutation", "FILTER")) %>% 
  ggplot(aes(value, fill = FILTER)) +
  geom_histogram() +
  facet_wrap(~ variable, scales = "free") +
  theme(legend.position = c(0.8, 0.2))
```

## `Strelka2` mutations

We originally planned to filter mutations with following filters:

* A read depth for the two sample between half and two times the mean coverage (`normal_DP <= 120, normal_DP >= 30, mutation_DP <= 120, mutation_DP >= 30`)
* A null number of alternate allele count in the normal sample (`normal_altCountT1 == 0`)
* A minimum of 10 alternate allele count in the mutated sample (`mutation_altCountT1 >= 10`)
* An allele frequency of mutations below 0.5 (`mutation_AF <= 0.5`)

But we obtained 1149 candidates.
We thus used the suggested automatic filter of `Strelka2`,
resulting in a robust dataset of 204 mutations (Fig \@ref(fig:mutRobust)).
Nevertheless, for comparisons with the `GATK` mutations we want automatic filtering based on simple metrics.
I thus compared the distribution of the robust and raw mutations for different metrics alone and pairwise (Fig. \@ref(fig:mutMetrics)).
It seemed that robust mutations had a lower maximum read depth for both samples (normal_DP and mutation_DP)
and a higher quality score (QSS, Fig. \@ref(fig:mutMetrics)).
We thus further filtered the mutations with following filters:

* A read depth for the two sample below 110% of the expected coverage (`normal_DP < 60*1.1, mutation_DP < 60*1.1`)
* A quality score above 20 (`QSS > 20`)

We thus obtained a filtered dataset of 333 mutations (Fig. \@ref(fig:mutFiltered)) 
comparable with Napoleon's original mutations and mutations obtained with `GATK`.
Together the candidates mutations have been filtered as follow:

* A read depth for the two sample between 50% and 110% of the expected coverage (`normal_DP < 60*1.1, normal_DP >= 30, mutation_DP < 60*1.1, mutation_DP >= 30`)
* A null number of alternate allele count in the normal sample (`normal_altCountT1 == 0`)
* A minimum of 10 alternate allele count in the mutated sample (`mutation_altCountT1 >= 10`)
* An allele frequency of mutations below 0.5 (`mutation_AF <= 0.5`)
* A quality score above 20 (`QSS > 20`)

```{r mutRaw}
mutRaw <- strelka2raw %>% 
  filter(normal_DP <= 120, normal_DP >= 30) %>% 
  filter(mutation_DP <= 120, mutation_DP >= 30) %>% 
  filter(normal_altCountT1 == 0) %>% 
  filter(mutation_altCountT1 >= 10) %>% 
  filter(mutation_AF <= 0.5) %>% 
  filter(mutation_altCountT1 < 30) %>% 
  collect() 
mutRobust <- filter(mutRaw, FILTER == "PASS")
```

```{r mutRobust, fig.cap="Robust mutations allele frequency (A) and positions on the 3P genome (B)."}
g1 <- ggplot(mutRobust, aes(mutation_AF)) +
  geom_histogram() +
  ggtitle("", paste("N =", nrow(mutRobust))) +
  xlab("Allele frequency")
g2 <- ggplot(genome, aes(x = CHROM, xend = CHROM)) +
  geom_segment(aes(y = start, yend = stop), size = 3, col = "lightgrey") +
  geom_point(aes(y = POS/10^6, col = mutation_AF), data = mutRobust, size = 1) +
  coord_flip() +
  ylab("Position (Mb)") +
  theme(axis.line.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank()) +
  viridis::scale_color_viridis(option = "inferno")
cowplot::plot_grid(g1, g2, nrow = 2, labels = c("A", "B"))
```

```{r mutMetrics, fig.cap="Different metrics single and pair plots for raw and robust mutations."}
GGally::ggpairs(mutRaw, aes(col = (FILTER == "PASS"), alpha = 0.2),
                columns = c("normal_DP", "mutation_DP", "mutation_altCountT1", "QSS"),
                upper = list(continuous = "density", combo = "box_no_facet", discrete = "facetbar", na = "na"),
                diag = list(continuous = "barDiag", discrete = "barDiag", na = "naDiag"), 
                progress = F)
```

```{r mutFiltered, fig.cap="Filtered mutations allele frequency (A) and positions on the 3P genome (B)."}
mutFiltered <- mutRaw %>% 
  filter(normal_DP < 60*1.1) %>%
  filter(mutation_DP < 60*1.1) %>%
  filter(QSS > 20)
g1 <- ggplot(mutFiltered, aes(mutation_AF)) +
  geom_histogram() +
  ggtitle("", paste("N =", nrow(mutFiltered))) +
  xlab("Allele frequency")
g2 <- ggplot(genome, aes(x = CHROM, xend = CHROM)) +
  geom_segment(aes(y = start, yend = stop), size = 3, col = "lightgrey") +
  geom_point(aes(y = POS/10^6, col = mutation_AF), data = mutFiltered, size = 1) +
  coord_flip() +
  ylab("Position (Mb)") +
  theme(axis.line.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank()) +
  viridis::scale_color_viridis(option = "inferno")
cowplot::plot_grid(g1, g2, nrow = 2, labels = c("A", "B"))
```

